// Generated by CoffeeScript 1.7.1

/*
--------------------------------------------
     Begin underhand.coffee
--------------------------------------------
 */

(function() {
  var JRule, ready, underhand,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  underhand = {};

  underhand.set_text = function(el, content) {
    if (el.innerText) {
      return el.innerText = content;
    } else {
      return el.textContent = content;
    }
  };

  underhand.add_events = function(events, el) {
    var e, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = events.length; _i < _len; _i++) {
      e = events[_i];
      if (el != null) {
        _results.push(el.addEventListener(e.type, e.fn));
      } else {
        _results.push(document.addEventListener(e.type, e.fn));
      }
    }
    return _results;
  };

  underhand.remove_events = function(events, el) {
    var e, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = events.length; _i < _len; _i++) {
      e = events[_i];
      if (el != null) {
        _results.push(el.removeEventListener(e.type, e.fn));
      } else {
        _results.push(document.removeEventListener(e.type, e.fn));
      }
    }
    return _results;
  };

  underhand.apply_styles = function(el, styles) {
    var key, val, _results;
    _results = [];
    for (key in styles) {
      val = styles[key];
      _results.push(el.style[key] = val);
    }
    return _results;
  };

  underhand.extend = function(first, second) {
    var key, val;
    if (first == null) {
      first = {};
    }
    if (second == null) {
      second = {};
    }
    for (key in second) {
      val = second[key];
      first[key] = val;
    }
    return first;
  };

  underhand.defaults = function(default_props, obj) {
    var key, val;
    if (obj == null) {
      obj = {};
    }
    for (key in default_props) {
      val = default_props[key];
      if (!obj.hasOwnProperty(key)) {
        obj[key] = val;
      }
    }
    return obj;
  };


  /*
  --------------------------------------------
       Begin JRule.coffee
  --------------------------------------------
   */

  JRule = (function() {
    JRule.talkative = 1;

    JRule.version = .5;

    JRule.zIndex = 999999;

    function JRule(opts) {
      this.opts = opts != null ? opts : {};
      this.setup_border_rulers();
      this.setup_caliper();
      this.setup_grid();
      this.setup_mandolin();
      this.mouse_tracker = JRule.MouseTracker.get_tracker();
      this.setup_events();
      if (typeof console !== "undefined" && console !== null) {
        console.log('jrule ready!');
      }
      JRule.Messenger.notify('jrule ready!');
      JRule.Messenger.notify('Press "h" to view help');
    }

    JRule.prototype.default_opts = function() {};

    JRule.prototype.destroy = function() {
      if (this.caliper) {
        this.caliper.destroy();
      }
      if (this.border_rulers) {
        this.border_rulers.destroy();
      }
      if (this.grid) {
        this.grid.destroy();
      }
      if (this.mouse_tracker) {
        this.mouse_tracker.destroy();
      }
      if (this.mandolin) {
        this.mandolin.destroy();
      }
      document.jruler = void 0;
      return typeof console !== "undefined" && console !== null ? console.log("Venni Vetti Vecci") : void 0;
    };

    JRule.prototype.setup_events = function() {
      var keydown;
      this.events || (this.events = []);
      keydown = (function(_this) {
        return function(e) {
          if (e.keyCode === 67) {
            return _this.toggle_crosshairs();
          } else if (e.keyCode === 82) {
            return _this.toggle_rulers();
          } else if (e.keyCode === 71) {
            return _this.toggle_grid();
          } else if (e.keyCode === 72) {
            return _this.toggle_help();
          } else if (e.keyCode === 77) {
            JRule.talkative = !JRule.talkative;
            return JRule.Messenger.notify("Messages " + (JRule.talkative ? 'on' : 'off'), {
              duration: 1000,
              force: true
            });
          } else if (e.keyCode === 27) {
            return _this.destroy();
          }
        };
      })(this);
      this.events.push({
        type: "keydown",
        fn: keydown
      });
      return underhand.add_events(this.events);
    };

    JRule.prototype.setup_border_rulers = function() {
      return this.border_rulers = new JRule.BorderRulers();
    };

    JRule.prototype.setup_caliper = function() {
      return this.caliper = new JRule.Caliper();
    };

    JRule.prototype.setup_grid = function() {
      return this.grid = new JRule.Grid();
    };

    JRule.prototype.setup_mandolin = function() {
      return this.mandolin = new JRule.Mandolin();
    };

    JRule.prototype.toggle_crosshairs = function() {
      var shown;
      shown = this.mouse_tracker.toggle_crosshairs();
      return JRule.Messenger.notify("Crosshairs " + (shown ? 'on' : 'off'), {
        duration: 1000
      });
    };

    JRule.prototype.toggle_rulers = function() {
      var shown;
      shown = this.border_rulers.toggle_visibility();
      return JRule.Messenger.notify("Rulers " + (shown ? 'on' : 'off'), {
        duration: 1000
      });
    };

    JRule.prototype.toggle_grid = function() {
      var shown;
      shown = this.grid.toggle_grid();
      return JRule.Messenger.notify("Grid " + (shown ? 'on' : 'off'), {
        duration: 1000
      });
    };

    JRule.prototype.toggle_help = function() {
      return JRule.Help.get().toggle();
    };

    JRule.prototype.config = function(what, settings) {
      var key, options, val, _results;
      if (settings == null) {
        settings = {};
      }
      options = what === 'crosshairs' ? this.mouse_tracker.config_items() : what === 'rulers' ? this.border_rulers.config_items() : void 0;
      _results = [];
      for (key in settings) {
        val = settings[key];
        if (options.indexOf(key) > -1) {
          switch (what) {
            case 'crosshairs':
              _results.push(this.mouse_tracker.config(key, val));
              break;
            case 'rulers':
              _results.push(this.border_rulers.config(key, val));
              break;
            default:
              _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return JRule;

  })();


  /*
  --------------------------------------------
       Begin GUIObject.coffee
  --------------------------------------------
   */

  JRule.GUIObject = (function() {
    function GUIObject(opts) {
      this.opts = opts != null ? opts : {};
      this.default_opts();
      this.create();
      this.setup_events();
    }

    GUIObject.prototype.destroy = function() {
      underhand.remove_events(this.events);
      document.body.removeChild(this.container);
      return this.destroyed = true;
    };

    GUIObject.prototype.default_opts = function() {};

    GUIObject.prototype.setup_events = function() {
      this.events || (this.events = []);
      return underhand.add_events(this.events, this.container);
    };

    GUIObject.prototype.classes = function() {
      return [];
    };

    GUIObject.prototype.create = function() {
      var d;
      d = document.createElement("div");
      d.className = this.classes().join(' ');
      this.container = d;
      document.body.appendChild(this.container);
      return underhand.apply_styles(this.container, this.style());
    };

    GUIObject.prototype.style = function() {
      return {
        position: "fixed",
        backgroundColor: "rgba(0, 0, 0, .6)",
        padding: "8px 12px",
        fontSize: "14px",
        fontFamily: "sans-serif",
        color: "#fff",
        cursor: "pointer",
        zIndex: JRule.zIndex + 10
      };
    };

    GUIObject.prototype.show = function() {
      this.container.style.display = "block";
      return this.visible = true;
    };

    GUIObject.prototype.hide = function() {
      this.container.style.display = "none";
      return this.visible = false;
    };

    GUIObject.prototype.toggle = function() {
      if (this.visible) {
        return this.hide();
      } else {
        return this.show();
      }
    };

    return GUIObject;

  })();


  /*
  --------------------------------------------
       Begin ColorWheel.coffee
  --------------------------------------------
   */

  JRule.ColorWheel = (function() {
    function ColorWheel() {}

    ColorWheel.rgb_string_to_hex = function(rgb) {
      var i, p, pieces, _i, _len;
      if (rgb == null) {
        rgb = "255, 255, 255";
      }
      pieces = rgb.split(',');
      rgb = [];
      for (i = _i = 0, _len = pieces.length; _i < _len; i = ++_i) {
        p = pieces[i];
        rgb[i] = parseInt(p);
      }
      return this.rgb_to_hex(rgb[0], rgb[1], rgb[2]);
    };

    ColorWheel.rgb_to_hex = function(r, g, b) {
      var convert, hex;
      if (r == null) {
        r = 0;
      }
      if (g == null) {
        g = 0;
      }
      if (b == null) {
        b = 0;
      }
      convert = function(i) {
        i = i.toString(16);
        if (i.length === 1) {
          i = "0" + i;
        }
        return i;
      };
      return hex = "" + (convert(r)) + (convert(g)) + (convert(b));
    };

    ColorWheel.hex_to_rgb = function(hex) {
      var b, char, g, proper_hex, r, rgb, _i, _len;
      if (hex == null) {
        hex = "ffffff";
      }
      hex = hex.replace("#", "");
      proper_hex = hex;
      if (hex.length === 3) {
        proper_hex = "";
        for (_i = 0, _len = hex.length; _i < _len; _i++) {
          char = hex[_i];
          proper_hex += char + char;
        }
      }
      r = proper_hex.substr(0, 2);
      g = proper_hex.substr(2, 2);
      b = proper_hex.substr(4, 2);
      return rgb = "" + (parseInt(r, 16)) + ", " + (parseInt(g, 16)) + ", " + (parseInt(b, 16));
    };

    ColorWheel.hex_to_rgba = function(hex, a) {
      if (hex == null) {
        hex = "fff";
      }
      if (a == null) {
        a = 1;
      }
      return this.hex_to_rgb(hex) + (", " + a);
    };

    return ColorWheel;

  })();


  /*
  --------------------------------------------
       Begin BorderRulers.coffee
  --------------------------------------------
   */

  JRule.BorderRulers = (function() {
    function BorderRulers(opts) {
      this.opts = opts != null ? opts : {};
      this.rulers = {};
      this.mouse_ticks = {};
      this.mouse_tracker = JRule.MouseTracker.get_tracker();
      this.default_opts();
      this.setup_rulers();
      this.setup_mouse_pos();
      this.setup_events();
    }

    BorderRulers.prototype.default_opts = function() {
      var defaults;
      defaults = {
        style: {
          backgroundColor: "rgba(" + (JRule.ColorWheel.hex_to_rgba('#aaa', .5)) + ")",
          opacity: .5,
          tickColor: "#f8f8f8",
          mouseTickColor: "#00f"
        },
        top: true,
        left: true,
        right: false,
        bottom: false,
        tick_distance: 200,
        rule_size: 25,
        divisions: 10,
        show_mouse: true,
        show_labels: true,
        start_in_center: true
      };
      return this.opts = defaults;
    };

    BorderRulers.prototype.config_items = function() {
      return ['divisions', 'tick_distance', 'show_mouse', 'show_labels'];
    };

    BorderRulers.prototype.config = function(what, value) {
      switch (what) {
        case 'divisions':
          this.opts.divisions = value;
          break;
        case 'tick_distance':
          this.opts.tick_distance = value;
          break;
        case 'show_mouse':
          this.opts.show_mosue = value;
          break;
        case 'show_labels':
          this.opts.show_labels = value;
      }
      return this.setup_rulers(true);
    };

    BorderRulers.prototype.get_style = function() {
      return {
        backgroundColor: this.opts.style.backgroundColor,
        opacity: this.opts.style.opacity
      };
    };

    BorderRulers.prototype.setup_rulers = function(force) {
      var create_ruler, left_ruler, name, ruler, top_ruler, _ref, _ref1;
      if (force == null) {
        force = false;
      }
      if (this.setup && !force) {
        return;
      }
      if (this.setup && force) {
        this.destroy_rulers();
      }
      create_ruler = (function(_this) {
        return function() {
          var rule, styles;
          rule = document.createElement("div");
          rule.className = "ruler";
          styles = _this.get_style();
          underhand.extend(styles, {
            position: "fixed",
            zIndex: JRule.zIndex
          });
          underhand.apply_styles(rule, styles);
          return rule;
        };
      })(this);
      if (this.opts.top) {
        top_ruler = create_ruler();
        underhand.apply_styles(top_ruler, {
          left: 0,
          right: 0,
          top: 0,
          height: "" + this.opts.rule_size + "px"
        });
        this.rulers.top = top_ruler;
      }
      if (this.opts.left) {
        left_ruler = create_ruler();
        underhand.apply_styles(left_ruler, {
          left: 0,
          top: 0,
          bottom: 0,
          width: "" + this.opts.rule_size + "px"
        });
        this.rulers.left = left_ruler;
      }
      _ref = this.rulers;
      for (name in _ref) {
        ruler = _ref[name];
        if ((_ref1 = document.body) != null) {
          _ref1.appendChild(ruler);
        }
      }
      this.setup_ticks();
      this.shown = true;
      return this.setup = true;
    };

    BorderRulers.prototype.setup_events = function() {
      var mousemove;
      this.events || (this.events = []);
      if (this.opts.show_mouse) {
        mousemove = (function(_this) {
          return function(e) {
            return _this.render();
          };
        })(this);
        this.events.push({
          type: "jrule:mousemove",
          fn: mousemove
        });
        return underhand.add_events(this.events, document.body);
      }
    };

    BorderRulers.prototype.tick_style = function(side) {
      var style;
      style = {
        position: "absolute",
        display: "block",
        backgroundColor: this.opts.style.tickColor
      };
      if (side === "top" || side === "bottom") {
        style.width = "1px";
        style.height = "100%";
      } else {
        style.width = "100%";
        style.height = "1px";
      }
      return style;
    };

    BorderRulers.prototype.create_label = function(side, pos) {
      var label, style;
      label = document.createElement("div");
      label.className = "tick_label";
      underhand.set_text(label, "" + pos + "px");
      style = {
        position: "absolute",
        fontSize: "10px",
        fontFamily: "sans-serif"
      };
      if (side === "top") {
        underhand.extend(style, {
          left: "" + pos + "px",
          bottom: "2px",
          marginLeft: "-14px"
        });
      } else {
        underhand.extend(style, {
          top: "" + pos + "px",
          left: "4px",
          "-webkit-transform": "rotate(-90deg)",
          "transform": "rotate(-90deg)",
          "-moz-transform": "rotate(-90deg)"
        });
      }
      underhand.apply_styles(label, style);
      return label;
    };

    BorderRulers.prototype.setup_ticks = function() {
      var div_pos, division_distance, doc_rect, i, j, side, tick_distance, tick_label, tick_pos, ticks, _i, _len, _ref, _results;
      doc_rect = document.body.getBoundingClientRect();
      ticks = Math.ceil(doc_rect.width / this.opts.tick_distance);
      tick_distance = Math.round(doc_rect.width / ticks);
      division_distance = Math.round(tick_distance / this.opts.divisions);
      _ref = ['top', 'left'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        side = _ref[_i];
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (i = _j = 0; 0 <= ticks ? _j < ticks : _j > ticks; i = 0 <= ticks ? ++_j : --_j) {
            tick_pos = i * this.opts.tick_distance;
            this.draw_tick(side, tick_pos, 1, {
              backgroundColor: "#666"
            });
            if (this.opts.show_labels) {
              tick_label = this.create_label(side, tick_pos);
              this.rulers[side].appendChild(tick_label);
            }
            _results1.push((function() {
              var _k, _ref1, _results2;
              _results2 = [];
              for (j = _k = 1, _ref1 = this.opts.divisions; 1 <= _ref1 ? _k <= _ref1 : _k >= _ref1; j = 1 <= _ref1 ? ++_k : --_k) {
                div_pos = j * division_distance + tick_pos;
                _results2.push(this.draw_tick(side, div_pos, (j % 2 ? .3 : .5)));
              }
              return _results2;
            }).call(this));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    BorderRulers.prototype.setup_mouse_pos = function() {
      var doc_rect, mouse_pos, mouse_x_tick, mouse_y_tick, style;
      doc_rect = document.body.getBoundingClientRect();
      if (this.opts.show_mouse) {
        if (this.rulers.hasOwnProperty('top')) {
          mouse_x_tick = this.create_tick('top', Math.round(doc_rect.width / 2), 1);
          mouse_x_tick.style.backgroundColor = "" + this.opts.style.mouseTickColor;
          this.mouse_ticks.x = mouse_x_tick;
          this.rulers.top.appendChild(this.mouse_ticks.x);
        }
        if (this.rulers.hasOwnProperty('left')) {
          mouse_y_tick = this.create_tick('left', Math.round(doc_rect.width / 2), 1);
          mouse_y_tick.style.backgroundColor = "" + this.opts.style.mouseTickColor;
          this.mouse_ticks.y = mouse_y_tick;
          this.rulers.left.appendChild(this.mouse_ticks.y);
        }
        mouse_pos = document.createElement("div");
        style = {
          position: "fixed",
          zIndex: JRule.zIndex + 1,
          left: 0,
          top: 0,
          padding: "6px",
          backgroundColor: "#888",
          color: "#fafafa",
          fontSize: "12px",
          fontFamily: "sans-serif",
          fontWeight: 100
        };
        underhand.apply_styles(mouse_pos, style);
        this.mouse_pos = mouse_pos;
        return document.body.appendChild(this.mouse_pos);
      }
    };

    BorderRulers.prototype.create_tick = function(side, pos, height, style_overrides) {
      var new_tick, style;
      if (height == null) {
        height = 1;
      }
      if (style_overrides == null) {
        style_overrides = {};
      }
      new_tick = document.createElement("div");
      style = underhand.extend(this.tick_style(side), style_overrides);
      new_tick.className = "tick";
      if (side === "top" || side === "bottom") {
        style.left = "" + pos + "px";
        style.height = "" + (100 * height) + "%";
      } else {
        style.top = "" + pos + "px";
        style.width = "" + (100 * height) + "%";
      }
      underhand.apply_styles(new_tick, style);
      return new_tick;
    };

    BorderRulers.prototype.draw_tick = function(side, pos, height, style_overrides) {
      var new_tick;
      if (height == null) {
        height = 1;
      }
      if (style_overrides == null) {
        style_overrides = {};
      }
      if (this.rulers.hasOwnProperty(side)) {
        new_tick = this.create_tick(side, pos, height, style_overrides);
        return this.rulers[side].appendChild(new_tick);
      } else {
        return false;
      }
    };

    BorderRulers.prototype.destroy_rulers = function() {
      var name, ruler, _ref, _results;
      _ref = this.rulers;
      _results = [];
      for (name in _ref) {
        ruler = _ref[name];
        _results.push(document.body.removeChild(ruler));
      }
      return _results;
    };

    BorderRulers.prototype.destroy = function() {
      underhand.remove_events(this.events, document.body);
      document.body.removeChild(this.mouse_pos);
      return this.destroy_rulers();
    };

    BorderRulers.prototype.render = function() {
      if (this.opts.show_mouse) {
        if (this.mouse_ticks.x) {
          this.mouse_ticks.x.style.left = "" + this.mouse_tracker.mousex + "px";
        }
        if (this.mouse_ticks.y) {
          this.mouse_ticks.y.style.top = "" + this.mouse_tracker.mousey + "px";
        }
        return underhand.set_text(this.mouse_pos, "" + this.mouse_tracker.mousex + ", " + this.mouse_tracker.mousey);
      }
    };

    BorderRulers.prototype.toggle_visibility = function() {
      var ruler, side, _ref;
      this.shown = !this.shown;
      _ref = this.rulers;
      for (side in _ref) {
        ruler = _ref[side];
        ruler.style.display = this.shown ? "block" : "none";
      }
      return this.shown;
    };

    return BorderRulers;

  })();


  /*
  --------------------------------------------
       Begin Caliper.coffee
  --------------------------------------------
   */

  JRule.Caliper = (function() {
    function Caliper(opts) {
      this.opts = opts != null ? opts : {};
      this.mouse_tracker = JRule.MouseTracker.get_tracker();
      this.crosshairs = [];
      this.setup_events();
    }

    Caliper.prototype.setup_events = function() {
      var keydown, mousemove;
      this.events || (this.events = []);
      keydown = (function(_this) {
        return function(e) {
          var keyup_fn;
          if (e.keyCode === 16) {
            _this.measuring = true;
            _this.start_pos = [_this.mouse_tracker.mousex, _this.mouse_tracker.mousey];
            _this.mark_spot_with_crosshair(_this.start_pos);
            document.body.style.cursor = "none";
            _this.setup_indicators();
            keyup_fn = function() {
              _this.measuring = false;
              _this.end_pos = [_this.mouse_tracker.mousex, _this.mouse_tracker.mousey];
              _this.last_size = [Math.abs(_this.end_pos[0] - _this.start_pos[0]), Math.abs(_this.end_pos[1] - _this.start_pos[1])];
              JRule.Messenger.notify("" + _this.last_size[0] + "x" + _this.last_size[1]);
              document.removeEventListener('keyup', keyup_fn);
              return _this.cleanup();
            };
            return document.addEventListener('keyup', keyup_fn);
          }
        };
      })(this);
      this.events.push({
        type: "keydown",
        fn: keydown
      });
      mousemove = (function(_this) {
        return function() {
          return _this.render();
        };
      })(this);
      this.events.push({
        type: "jrule:mousemove",
        fn: mousemove
      });
      underhand.add_events([
        {
          type: "keydown",
          fn: keydown
        }
      ]);
      return underhand.add_events([
        {
          type: "jrule:mousemove",
          fn: mousemove
        }
      ], document.body);
    };

    Caliper.prototype.render = function() {
      var h_dir, height, indicator_size_style, indicator_style, v_dir, width, x, y;
      if (this.measuring) {
        x = Math.min(this.mouse_tracker.mousex, this.start_pos[0]);
        y = Math.min(this.mouse_tracker.mousey, this.start_pos[1]);
        width = Math.max(this.mouse_tracker.mousex, this.start_pos[0]) - Math.min(this.mouse_tracker.mousex, this.start_pos[0]);
        height = Math.max(this.mouse_tracker.mousey, this.start_pos[1]) - Math.min(this.mouse_tracker.mousey, this.start_pos[1]);
        indicator_style = {
          width: "" + width + "px",
          height: "" + height + "px",
          left: "" + x + "px",
          top: "" + y + "px",
          zIndex: JRule.zIndex
        };
        underhand.apply_styles(this.indicator, indicator_style);
        indicator_size_style = {
          display: 'block'
        };
        h_dir = this.start_pos[0] > this.mouse_tracker.mousex ? "left" : "right";
        v_dir = this.start_pos[1] > this.mouse_tracker.mousey ? "up" : "down";
        this.drag_direction = [h_dir, v_dir];
        if (h_dir === "left") {
          indicator_size_style.left = 0;
          indicator_size_style.right = "auto";
        } else {
          indicator_size_style.right = 0;
          indicator_size_style.left = "auto";
        }
        if (v_dir === "up") {
          indicator_size_style.top = 0;
          indicator_size_style.bottom = "auto";
        } else {
          indicator_size_style.bottom = 0;
          indicator_size_style.top = "auto";
        }
        underhand.apply_styles(this.indicator_size, indicator_size_style);
        return underhand.set_text(this.indicator_size, "" + width + ", " + height);
      }
    };

    Caliper.prototype.setup_indicators = function() {
      var i_style, indicator, indicator_size, is_style;
      indicator = document.createElement("div");
      i_style = {
        position: "fixed",
        left: "" + this.start_pos[0] + "px",
        top: "" + this.start_pos[1] + "px",
        backgroundColor: "rgba(100, 100, 100, .4)",
        zIndex: JRule.zIndex
      };
      this.indicator = indicator;
      underhand.apply_styles(this.indicator, i_style);
      document.body.appendChild(this.indicator);
      indicator_size = document.createElement("div");
      is_style = {
        position: "absolute",
        right: 0,
        bottom: 0,
        fontFamily: "sans-serif",
        fontSize: "12px",
        backgroundColor: "#000",
        color: "#fff",
        padding: "3px",
        zIndex: 1
      };
      this.indicator_size = indicator_size;
      underhand.apply_styles(this.indicator_size, is_style);
      return this.indicator.appendChild(this.indicator_size);
    };

    Caliper.prototype.mark_spot_with_crosshair = function(pos) {
      var c, _i, _len, _ref, _results;
      this.crosshairs.push(JRule.Crosshair.create('x', "" + pos[0] + "px"));
      this.crosshairs.push(JRule.Crosshair.create('y', "" + pos[1] + "px"));
      _ref = this.crosshairs;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(document.body.appendChild(c));
      }
      return _results;
    };

    Caliper.prototype.cleanup = function() {
      var c, _i, _len, _ref;
      this.indicator.removeChild(this.indicator_size);
      document.body.removeChild(this.indicator);
      _ref = this.crosshairs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        document.body.removeChild(c);
      }
      this.crosshairs = [];
      return document.body.style.cursor = "default";
    };

    Caliper.prototype.destroy = function() {
      var e, keydown, mousemove, _i, _len, _ref;
      keydown = null;
      mousemove = null;
      _ref = this.events;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        e = _ref[_i];
        if (e.type === "keydown") {
          keydown = e;
        }
        if (e.type === "jrule:mousemove") {
          mousemove = e;
        }
      }
      if (keydown) {
        underhand.remove_events([
          {
            type: "keydown",
            fn: keydown.fn
          }
        ]);
      }
      if (mousemove) {
        return underhand.remove_events([
          {
            type: "jrule:mousemove",
            fn: mousemove.fn
          }
        ], document.body);
      }
    };

    return Caliper;

  })();


  /*
  --------------------------------------------
       Begin Crosshair.coffee
  --------------------------------------------
   */

  JRule.Crosshair = (function() {
    function Crosshair() {}

    Crosshair.create = function(axis, pos, style) {
      var crosshair, key, style_defaults, styles, val;
      if (pos == null) {
        pos = "50%";
      }
      if (style == null) {
        style = {};
      }
      style_defaults = {
        crosshairColor: "rgba(100, 100, 100, .5)",
        crosshairThickness: 1
      };
      for (key in style_defaults) {
        val = style_defaults[key];
        if (!style.hasOwnProperty(key)) {
          style[key] = val;
        }
      }
      crosshair = document.createElement("div");
      styles = {
        position: "fixed",
        backgroundColor: "" + style.crosshairColor,
        zIndex: JRule.zIndex
      };
      crosshair.className = "crosshair";
      if (axis === "x" || axis === "horizontal") {
        underhand.extend(styles, {
          width: "" + style.crosshairThickness + "px",
          top: 0,
          bottom: 0,
          left: "" + pos
        });
      } else {
        underhand.extend(styles, {
          height: "" + style.crosshairThickness + "px",
          left: 0,
          right: 0,
          top: "" + pos
        });
      }
      underhand.apply_styles(crosshair, styles);
      return crosshair;
    };

    return Crosshair;

  })();


  /*
  --------------------------------------------
       Begin Grid.coffee
  --------------------------------------------
   */

  JRule.Grid = (function() {
    function Grid(opts) {
      this.opts = opts != null ? opts : {};
      this.default_opts();
      this.setup_grid();
      this.setup_events();
    }

    Grid.prototype.default_opts = function() {
      var defaults, key, key2, val, val2, _ref;
      defaults = {
        tick_distance: 100,
        divisions: 3,
        show: false,
        start_in_center: true,
        style: {
          tickLineColor: "rgba(191, 231, 243, .6)",
          divisionLineColor: "rgba(220, 220, 220, .3)",
          centerLineColor: "rgba(255, 0, 0, .3)"
        }
      };
      for (key in defaults) {
        val = defaults[key];
        if (!this.opts.hasOwnProperty(key)) {
          this.opts[key] = val;
        } else if (typeof this.opts[key] === "object") {
          _ref = this.opts[key];
          for (key2 in _ref) {
            val2 = _ref[key2];
            if (!this.opts[key].hasOwnProperty(key2)) {
              this.opts[key][key] = val2;
            }
          }
        }
      }
      return this.opts;
    };

    Grid.prototype.setup_events = function() {
      var resize;
      this.events || (this.events = []);
      this.window_resizing = false;
      this.resize_to = null;
      resize = (function(_this) {
        return function(e) {
          if (_this.window_resizing) {
            if (_this.resize_to) {
              clearTimeout(_this.resize_to);
            }
            return _this.resize_to = setTimeout(function() {
              _this.window_resizing = false;
              _this.setup_grid();
              return _this.show_ticks();
            }, 400);
          } else {
            _this.window_resizing = true;
            return _this.cleanup();
          }
        };
      })(this);
      return underhand.add_events(this.events, window);
    };

    Grid.prototype.setup_grid = function() {
      var center_x, center_y, division_distance, i, n, num_ticks, offset, t, x_offset, y_offset, _i, _j, _k, _l, _len, _m, _ref, _ref1, _ref2, _ref3;
      center_x = Math.round(document.documentElement.clientWidth / 2);
      center_y = Math.round(document.documentElement.clientHeight / 2);
      num_ticks = Math.ceil(document.documentElement.clientWidth / this.opts.tick_distance);
      division_distance = this.opts.divisions > 0 ? Math.round(this.opts.tick_distance / this.opts.divisions) : 0;
      this.ticks = [];
      if (this.opts.start_in_center) {
        num_ticks = num_ticks / 2;
        this.ticks.push(JRule.Crosshair.create('x', "" + center_x + "px", {
          crosshairColor: this.opts.style.centerLineColor
        }));
        this.ticks.push(JRule.Crosshair.create('y', "" + center_y + "px", {
          crosshairColor: this.opts.style.centerLineColor
        }));
        if (this.opts.divisions > 0) {
          for (n = _i = 1, _ref = this.opts.divisions; 1 <= _ref ? _i < _ref : _i > _ref; n = 1 <= _ref ? ++_i : --_i) {
            this.ticks.push(JRule.Crosshair.create('x', "" + (center_x + n * division_distance) + "px", {
              crosshairColor: this.opts.style.divisionLineColor
            }));
            this.ticks.push(JRule.Crosshair.create('y', "" + (center_y + n * division_distance) + "px", {
              crosshairColor: this.opts.style.divisionLineColor
            }));
            this.ticks.push(JRule.Crosshair.create('x', "" + (center_x - n * division_distance) + "px", {
              crosshairColor: this.opts.style.divisionLineColor
            }));
            this.ticks.push(JRule.Crosshair.create('y', "" + (center_y - n * division_distance) + "px", {
              crosshairColor: this.opts.style.divisionLineColor
            }));
          }
        }
      }
      for (i = _j = 1; 1 <= num_ticks ? _j < num_ticks : _j > num_ticks; i = 1 <= num_ticks ? ++_j : --_j) {
        offset = i * this.opts.tick_distance;
        x_offset = this.opts.start_in_center ? center_x + offset : offset;
        y_offset = this.opts.start_in_center ? center_y + offset : offset;
        this.ticks.push(JRule.Crosshair.create('x', "" + x_offset + "px", {
          crosshairColor: this.opts.style.tickLineColor
        }));
        this.ticks.push(JRule.Crosshair.create('y', "" + y_offset + "px", {
          crosshairColor: this.opts.style.tickLineColor
        }));
        if (this.opts.divisions > 0) {
          for (n = _k = 1, _ref1 = this.opts.divisions; 1 <= _ref1 ? _k < _ref1 : _k > _ref1; n = 1 <= _ref1 ? ++_k : --_k) {
            this.ticks.push(JRule.Crosshair.create('x', "" + (x_offset + n * division_distance) + "px", {
              crosshairColor: this.opts.style.divisionLineColor
            }));
            this.ticks.push(JRule.Crosshair.create('y', "" + (y_offset + n * division_distance) + "px", {
              crosshairColor: this.opts.style.divisionLineColor
            }));
          }
        }
        if (this.opts.start_in_center) {
          this.ticks.push(JRule.Crosshair.create('x', "" + (center_x - offset) + "px", {
            crosshairColor: this.opts.style.tickLineColor
          }));
          this.ticks.push(JRule.Crosshair.create('y', "" + (center_y - offset) + "px", {
            crosshairColor: this.opts.style.tickLineColor
          }));
          if (this.opts.divisions > 0) {
            for (n = _l = 1, _ref2 = this.opts.divisions; 1 <= _ref2 ? _l < _ref2 : _l > _ref2; n = 1 <= _ref2 ? ++_l : --_l) {
              this.ticks.push(JRule.Crosshair.create('x', "" + (center_x - offset - n * division_distance) + "px", {
                crosshairColor: this.opts.style.divisionLineColor
              }));
              this.ticks.push(JRule.Crosshair.create('y', "" + (center_y - offset - n * division_distance) + "px", {
                crosshairColor: this.opts.style.divisionLineColor
              }));
            }
          }
        }
      }
      _ref3 = this.ticks;
      for (_m = 0, _len = _ref3.length; _m < _len; _m++) {
        t = _ref3[_m];
        document.body.appendChild(t);
      }
      if (this.opts.show) {
        return this.show_ticks();
      } else {
        return this.hide_ticks();
      }
    };

    Grid.prototype.cleanup = function() {
      var t, _i, _len, _ref, _results;
      _ref = this.ticks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        _results.push(document.body.removeChild(t));
      }
      return _results;
    };

    Grid.prototype.hide_ticks = function() {
      var t, _i, _len, _ref, _results;
      this.shown = false;
      _ref = this.ticks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        _results.push(t.style.display = "none");
      }
      return _results;
    };

    Grid.prototype.show_ticks = function() {
      var t, _i, _len, _ref, _results;
      this.shown = true;
      _ref = this.ticks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        _results.push(t.style.display = "block");
      }
      return _results;
    };

    Grid.prototype.toggle_grid = function() {
      this.shown = !this.shown;
      if (this.shown) {
        this.show_ticks();
      } else {
        this.hide_ticks();
      }
      return this.shown;
    };

    Grid.prototype.destroy = function() {
      this.cleanup();
      return underhand.remove_events(this.events, window);
    };

    return Grid;

  })();


  /*
  --------------------------------------------
       Begin Mandolin.coffee
  --------------------------------------------
   */

  JRule.Mandolin = (function() {
    function Mandolin(opts) {
      this.opts = opts != null ? opts : {};
      this.slices = [];
      this.tracker = JRule.MouseTracker.get_tracker();
      this.default_opts();
      this.setup_events();
    }

    Mandolin.prototype.default_opts = function() {
      var defaults;
      defaults = {
        snap: false,
        snap_to: 10,
        style: {
          sliceColor: "rgba(150, 150, 150, .5)"
        }
      };
      return this.opts = underhand.defaults(defaults, this.opts);
    };

    Mandolin.prototype.setup_events = function() {
      var keydown;
      this.events || (this.events = []);
      keydown = (function(_this) {
        return function(e) {
          if (e.keyCode === 83) {
            return _this.create_slice_at_mouse();
          } else if (e.keyCode === 68) {
            return _this.create_divide_at_mouse();
          }
        };
      })(this);
      this.events.push({
        type: "keydown",
        fn: keydown
      });
      return underhand.add_events(this.events);
    };

    Mandolin.prototype.get_snap_for = function(pos) {
      var i, snap_to, snapped;
      snap_to = pos;
      snapped = pos % this.opts.snap_to === 0;
      i = 0;
      while (!snapped) {
        i += 1;
        if ((pos + i) % this.opts.snap_to === 0) {
          snap_to = pos + i;
          snapped = true;
        } else if ((pos - i) % this.opts.snap_to === 0) {
          snap_to = pos - i;
          snapped = true;
        }
      }
      return snap_to;
    };

    Mandolin.prototype.create_slice = function(pos) {
      var slice;
      if (this.opts.snap) {
        pos = this.get_snap_for(pos);
      }
      slice = JRule.Crosshair.create('x', "" + pos + "px", {
        backgroundColor: this.opts.style.sliceColor
      });
      JRule.Messenger.notify("Slice created at " + pos + "px");
      document.body.appendChild(slice);
      return this.slices.push(slice);
    };

    Mandolin.prototype.create_divide = function(pos) {
      var slice;
      if (this.opts.snap) {
        pos = this.get_snap_for(pos);
      }
      slice = JRule.Crosshair.create('y', "" + pos + "px", {
        backgroundColor: this.opts.style.sliceColor
      });
      JRule.Messenger.notify("Divide created at " + pos + "px");
      document.body.appendChild(slice);
      return this.slices.push(slice);
    };

    Mandolin.prototype.create_slice_at_mouse = function() {
      return this.create_slice(this.tracker.mousex);
    };

    Mandolin.prototype.create_divide_at_mouse = function() {
      return this.create_divide(this.tracker.mousey);
    };

    Mandolin.prototype.clear_slices = function() {
      var s, _i, _len, _ref;
      _ref = this.slices;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        document.body.removeChild(s);
      }
      return this.slices = [];
    };

    Mandolin.prototype.hide_slices = function() {
      var s, _i, _len, _ref, _results;
      _ref = this.slices;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        _results.push(s.style.display = "none");
      }
      return _results;
    };

    Mandolin.prototype.show_slices = function() {
      var s, _i, _len, _ref, _results;
      _ref = this.slices;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        _results.push(s.style.display = "block");
      }
      return _results;
    };

    Mandolin.prototype.destroy = function() {
      this.clear_slices();
      return underhand.remove_events(this.events);
    };

    return Mandolin;

  })();


  /*
  --------------------------------------------
       Begin Messenger.coffee
  --------------------------------------------
   */

  JRule.Messenger = (function() {
    function Messenger() {}

    Messenger.notify = function(msg, opts) {
      if (opts == null) {
        opts = {};
      }
      if (!JRule.talkative && !opts.force) {
        return;
      }
      if (opts.is_html) {
        opts.html_content = msg;
        opts.content = '';
      }
      msg = new JRule.Messenger.Notification(underhand.extend({
        content: msg,
        is_flash: true
      }, opts));
      return this.add_message_to_stack(msg);
    };

    Messenger.flash = function(msg, opts) {
      if (opts == null) {
        opts = {};
      }
      if (!JRule.talkative && !opts.force) {
        return;
      }
      if (opts.is_html) {
        opts.html_content = msg;
        opts.content = '';
      }
      msg = new JRule.Messenger.Flash(underhand.extend({
        content: msg,
        is_flash: true
      }, opts));
      return this.add_message_to_stack(msg);
    };

    Messenger.add_message_to_stack = function(msg) {
      var i, m, request_cleanup, y, _i, _len, _ref;
      this.message_stack || (this.message_stack = []);
      this.message_stack.push(msg);
      if (this.message_stack.length > 1) {
        y = 36;
        request_cleanup = false;
        _ref = this.message_stack;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          m = _ref[i];
          if (!m) {
            request_cleanup = true;
          } else if (m.visible) {
            m.container.style.top = "" + y + "px";
            y += m.container.clientHeight + 6;
          } else if (m.destroyed) {
            delete this.message_stack[i];
            request_cleanup = true;
          }
        }
        if (request_cleanup) {
          return this.cleanup_message_stack();
        }
      }
    };

    Messenger.cleanup_message_stack = function() {
      var copy, m, _i, _len, _ref;
      copy = [];
      _ref = this.message_stack;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        m = _ref[_i];
        if (m && !m.destroyed) {
          copy.push(m);
        }
      }
      return this.message_stack = copy;
    };

    return Messenger;

  })();

  JRule.Messenger.Message = (function(_super) {
    __extends(Message, _super);

    function Message() {
      return Message.__super__.constructor.apply(this, arguments);
    }

    Message.prototype.setup_events = function() {
      var mouseenter, mouseleave, onclick;
      this.events || (this.events = []);
      if (!this.container) {
        return;
      }
      onclick = (function(_this) {
        return function(e) {
          if (e.target.tagName.toLowerCase() === "a") {
            return true;
          }
          e.preventDefault();
          return _this.hide();
        };
      })(this);
      this.events.push({
        type: 'click',
        fn: onclick
      });
      mouseenter = (function(_this) {
        return function(e) {
          if (_this.timeout) {
            return clearTimeout(_this.timeout);
          }
        };
      })(this);
      this.events.push({
        type: 'mouseenter',
        fn: mouseenter
      });
      mouseleave = (function(_this) {
        return function(e) {
          return _this.timeout = setTimeout(function() {
            return _this.hide();
          }, 500);
        };
      })(this);
      this.events.push({
        type: 'mouseleave',
        fn: mouseleave
      });
      return underhand.add_events(this.events, this.container);
    };

    Message.prototype.default_opts = function() {
      var defaults;
      defaults = {
        content: '',
        html_content: false,
        duration: 5000,
        show: true,
        is_flash: false,
        type: '',
        colors: {
          alert: "rgba(0, 0, 0, .75)",
          error: "rgba(0, 0, 0, .75)"
        }
      };
      return this.opts = underhand.defaults(defaults, this.opts);
    };

    Message.prototype.classes = function() {
      return ["message", this.opts.type];
    };

    Message.prototype.style = function() {
      var style;
      style = {
        display: "none"
      };
      if (this.opts.colors.hasOwnProperty(this.opts.type)) {
        style.backgroundColor = this.opts.colors[this.opts.type];
      }
      return underhand.extend(Message.__super__.style.call(this), style);
    };

    Message.prototype.create = function() {
      Message.__super__.create.apply(this, arguments);
      if (this.opts.html_content) {
        this.container.innerHTML = this.opts.html_content;
      } else {
        underhand.set_text(this.container, this.opts.content);
      }
      if (this.opts.show) {
        return this.show();
      }
    };

    Message.prototype.show = function() {
      Message.__super__.show.apply(this, arguments);
      if (this.opts.duration) {
        return this.timeout = setTimeout((function(_this) {
          return function() {
            return _this.hide();
          };
        })(this), this.opts.duration);
      }
    };

    Message.prototype.hide = function() {
      Message.__super__.hide.apply(this, arguments);
      if (this.timeout) {
        clearTimeout(this.timeout);
      }
      if (this.opts.is_flash) {
        return this.destroy();
      }
    };

    return Message;

  })(JRule.GUIObject);

  JRule.Messenger.Notification = (function(_super) {
    __extends(Notification, _super);

    function Notification() {
      return Notification.__super__.constructor.apply(this, arguments);
    }

    Notification.prototype.style = function() {
      var style;
      style = {
        top: "36px",
        right: "10px",
        display: "none",
        borderRadius: "3px",
        minWidth: "200px",
        maxWidth: "300px",
        textAlign: "left"
      };
      return underhand.extend(Notification.__super__.style.call(this), style);
    };

    return Notification;

  })(JRule.Messenger.Message);

  JRule.Messenger.Flash = (function(_super) {
    __extends(Flash, _super);

    function Flash() {
      return Flash.__super__.constructor.apply(this, arguments);
    }

    Flash.prototype.style = function() {
      return underhand.extend(Flash.__super__.style.apply(this, arguments), {
        top: 0,
        left: 0,
        right: 0,
        textAlign: "center",
        fontSize: "18px",
        padding: "12px",
        backgroundColor: "#333"
      });
    };

    Flash.prototype.default_opts = function() {
      return this.opts = underhand.extend(Flash.__super__.default_opts.apply(this, arguments), {
        is_flash: true,
        duration: 3000
      });
    };

    return Flash;

  })(JRule.Messenger.Message);


  /*
  --------------------------------------------
       Begin Help.coffee
  --------------------------------------------
   */

  JRule.Help = (function(_super) {
    __extends(Help, _super);

    function Help() {
      return Help.__super__.constructor.apply(this, arguments);
    }

    Help.get = function() {
      return this.help || (this.help = new JRule.Help());
    };

    Help.prototype.default_opts = function() {
      var content;
      content = "Welcome to JRule! Thanks for using it. <br><br> JRule helps you measure and line things up. It's simple to use, here are some controls: <br> Press 'c' to toggle the Crosshairs<br> Press 'g' to toggle the Grid<br> Press 'r' to toggle the Rulers<br> Hold 'shift' and move the mouse to Measure<br> Press 'h' to see this message again<br> Click this message to get rid of it<br> Press 'escape' to remove JRule when you're done<br>";
      return underhand.extend(Help.__super__.default_opts.apply(this, arguments), {
        html_content: content,
        is_flash: false,
        show: false,
        duration: 0
      });
    };

    return Help;

  })(JRule.Messenger.Notification);


  /*
  --------------------------------------------
       Begin MouseTracker.coffee
  --------------------------------------------
   */

  JRule.MouseTracker = (function() {
    MouseTracker.get_tracker = function() {
      return this.tracker || (this.tracker = new JRule.MouseTracker());
    };

    function MouseTracker(opts) {
      this.opts = opts != null ? opts : {};
      this.crosshairs = null;
      this.default_opts();
      this.setup_events();
      if (this.opts.show_crosshairs) {
        this.setup_crosshairs();
      }
    }

    MouseTracker.prototype.default_opts = function() {
      var defaults;
      defaults = {
        show_crosshairs: true,
        style: {
          crosshairColor: "rgba(100, 100, 100, .6)",
          crosshairThickness: 1
        }
      };
      return underhand.defaults(defaults, this.opts);
    };

    MouseTracker.prototype.setup_events = function() {
      var keydown, mousemove;
      this.events || (this.events = []);
      mousemove = (function(_this) {
        return function(e) {
          var event;
          _this.mousex = e.clientX;
          _this.mousey = e.clientY;
          event = new Event('jrule:mousemove');
          document.body.dispatchEvent(event);
          if (_this.opts.show_crosshairs) {
            return _this.render_crosshairs();
          }
        };
      })(this);
      this.events.push({
        type: "mousemove",
        fn: mousemove
      });
      keydown = (function(_this) {
        return function(e) {
          if (e.keyCode === 187) {
            return _this.increase_crosshair_size();
          } else if (e.keyCode === 189) {
            return _this.decrease_crosshair_size();
          }
        };
      })(this);
      this.events.push({
        type: "keydown",
        fn: keydown
      });
      return underhand.add_events(this.events);
    };

    MouseTracker.prototype.increase_crosshair_size = function() {
      this.opts.style.crosshairThickness += 1;
      this.update();
      return JRule.Messenger.notify("" + this.opts.style.crosshairThickness + "px", {
        duration: 600
      });
    };

    MouseTracker.prototype.decrease_crosshair_size = function() {
      this.opts.style.crosshairThickness = Math.max(1, this.opts.style.crosshairThickness - 1);
      this.update();
      return JRule.Messenger.notify("" + this.opts.style.crosshairThickness + "px", {
        duration: 600
      });
    };

    MouseTracker.prototype.setup_crosshairs = function() {
      var c, coord, _ref, _results;
      this.crosshairs = {};
      this.crosshairs.x = JRule.Crosshair.create('x', "50%", this.opts.style);
      this.crosshairs.y = JRule.Crosshair.create('y', "50%", this.opts.style);
      _ref = this.crosshairs;
      _results = [];
      for (coord in _ref) {
        c = _ref[coord];
        _results.push(document.body.appendChild(c));
      }
      return _results;
    };

    MouseTracker.prototype.render_crosshairs = function() {
      var offset;
      if (!this.crosshairs) {
        this.setup_crosshairs();
      }
      offset = this.opts.style.crosshairThickness === 1 ? 0 : Math.round(this.opts.style.crosshairThickness / 2);
      this.crosshairs.x.style.left = "" + (this.mousex - offset) + "px";
      return this.crosshairs.y.style.top = "" + (this.mousey - offset) + "px";
    };

    MouseTracker.prototype.toggle_crosshairs = function() {
      this.opts.show_crosshairs = !this.opts.show_crosshairs;
      if (!this.opts.show_crosshairs) {
        this.remove_crosshairs();
      }
      return this.opts.show_crosshairs;
    };

    MouseTracker.prototype.remove_crosshairs = function() {
      var c, coord, _ref;
      _ref = this.crosshairs;
      for (coord in _ref) {
        c = _ref[coord];
        document.body.removeChild(c);
      }
      return this.crosshairs = null;
    };

    MouseTracker.prototype.destroy = function() {
      this.remove_crosshairs();
      return underhand.remove_events(this.events);
    };

    MouseTracker.prototype.config_items = function() {
      return ['crosshair_size', 'crosshair_color'];
    };

    MouseTracker.prototype.config = function(what, value) {
      switch (what) {
        case 'crosshair_size':
          this.opts.style.crosshairThickness = Math.max(1, parseInt(value));
          break;
        case 'crosshair_color':
          this.opts.style.crosshairColor = value;
      }
      this.update();
      return this.render_crosshairs();
    };

    MouseTracker.prototype.update = function() {
      var c, key, _ref, _ref1, _ref2;
      _ref = this.crosshairs;
      for (key in _ref) {
        c = _ref[key];
        c.style.backgroundColor = this.opts.style.crosshairColor;
      }
      if ((_ref1 = this.crosshairs.x) != null) {
        _ref1.style.width = "" + this.opts.style.crosshairThickness + "px";
      }
      return (_ref2 = this.crosshairs.y) != null ? _ref2.style.height = "" + this.opts.style.crosshairThickness + "px" : void 0;
    };

    return MouseTracker;

  })();


  /*
  --------------------------------------------
       Begin main.coffee
  --------------------------------------------
   */

  document.JRule = JRule;

  ready = function() {
    return document.jruler = new document.JRule();
  };

  if (document.readyState !== "complete") {
    document.addEventListener('DOMContentLoaded', function() {
      return ready();
    });
  } else {
    ready();
  }

}).call(this);
