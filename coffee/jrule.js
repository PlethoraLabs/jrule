// Generated by CoffeeScript 1.7.1
(function() {
  var JRule, ready, set_text;

  set_text = function(el, content) {
    if (el.innerText) {
      return el.innerText = content;
    } else {
      return el.textContent = content;
    }
  };

  JRule = (function() {
    function JRule(opts) {
      this.opts = opts != null ? opts : {};
      this.setup_border_rulers();
      this.setup_caliper();
      this.setup_grid();
      this.mouse_tracker = JRule.MouseTracker.get_tracker();
      this.setup_events();
      if (typeof console !== "undefined" && console !== null) {
        console.log('jrule ready!');
      }
    }

    JRule.prototype.default_opts = function() {};

    JRule.prototype.setup_events = function() {
      return document.addEventListener('keydown', (function(_this) {
        return function(e) {
          if (e.keyCode === 67) {
            return _this.toggle_crosshairs();
          } else if (e.keyCode === 82) {
            return _this.toggle_rulers();
          } else if (e.keyCode === 71) {
            return _this.toggle_grid();
          }
        };
      })(this));
    };

    JRule.prototype.setup_border_rulers = function() {
      return this.border_rulers = new JRule.BorderRulers();
    };

    JRule.prototype.setup_caliper = function() {
      return this.caliper = new JRule.Caliper();
    };

    JRule.prototype.setup_grid = function() {
      return this.grid = new JRule.Grid();
    };

    JRule.prototype.toggle_crosshairs = function() {
      return this.mouse_tracker.toggle_crosshairs();
    };

    JRule.prototype.toggle_rulers = function() {
      return this.border_rulers.toggle_visibility();
    };

    JRule.prototype.toggle_grid = function() {
      return this.grid.toggle_grid();
    };

    return JRule;

  })();

  JRule.Crosshair = (function() {
    function Crosshair() {}

    Crosshair.create = function(axis, pos, style) {
      var crosshair, key, style_defaults, val;
      if (pos == null) {
        pos = "50%";
      }
      if (style == null) {
        style = {};
      }
      style_defaults = {
        crosshairColor: "rgba(100, 100, 100, .5)",
        crosshairThickness: 1
      };
      for (key in style_defaults) {
        val = style_defaults[key];
        if (!style.hasOwnProperty(key)) {
          style[key] = val;
        }
      }
      crosshair = document.createElement("div");
      crosshair.style.position = "fixed";
      crosshair.style.backgroundColor = "" + style.crosshairColor;
      crosshair.style.zIndex = 4000;
      crosshair.className = "crosshair";
      if (axis === "x" || axis === "horizontal") {
        crosshair.style.width = "" + style.crosshairThickness + "px";
        crosshair.style.top = 0;
        crosshair.style.bottom = 0;
        crosshair.style.left = "" + pos;
      } else {
        crosshair.style.height = "" + style.crosshairThickness + "px";
        crosshair.style.left = 0;
        crosshair.style.right = 0;
        crosshair.style.top = "" + pos;
      }
      return crosshair;
    };

    return Crosshair;

  })();

  JRule.MouseTracker = (function() {
    MouseTracker.get_tracker = function() {
      return this.tracker || (this.tracker = new JRule.MouseTracker());
    };

    function MouseTracker(opts) {
      this.opts = opts != null ? opts : {};
      this.crosshairs = null;
      this.default_opts();
      this.setup_events();
      if (this.opts.show_crosshairs) {
        this.setup_crosshairs();
      }
    }

    MouseTracker.prototype.default_opts = function() {
      var defaults, key, val;
      defaults = {
        show_crosshairs: true,
        style: {
          crosshairColor: "rgba(100, 100, 100, .6)",
          crosshairThickness: 1
        }
      };
      for (key in defaults) {
        val = defaults[key];
        if (!this.opts.hasOwnProperty(key)) {
          this.opts[key] = val;
        }
      }
      return this.opts;
    };

    MouseTracker.prototype.setup_events = function() {
      document.addEventListener('mousemove', (function(_this) {
        return function(e) {
          var event;
          _this.mousex = e.clientX;
          _this.mousey = e.clientY;
          event = new Event('jrule:mousemove');
          document.body.dispatchEvent(event);
          if (_this.opts.show_crosshairs) {
            return _this.render_crosshairs();
          }
        };
      })(this));
      return document.addEventListener('keydown', (function(_this) {
        return function(e) {
          if (e.keyCode === 187) {
            return _this.increase_crosshair_size();
          } else if (e.keyCode === 189) {
            return _this.decrease_crosshair_size();
          }
        };
      })(this));
    };

    MouseTracker.prototype.increase_crosshair_size = function() {
      var _ref, _ref1;
      this.opts.style.crosshairThickness += 1;
      if ((_ref = this.crosshairs.x) != null) {
        _ref.style.width = "" + this.opts.style.crosshairThickness + "px";
      }
      return (_ref1 = this.crosshairs.y) != null ? _ref1.style.height = "" + this.opts.style.crosshairThickness + "px" : void 0;
    };

    MouseTracker.prototype.decrease_crosshair_size = function() {
      var _ref, _ref1;
      this.opts.style.crosshairThickness = Math.max(1, this.opts.style.crosshairThickness - 1);
      if ((_ref = this.crosshairs.x) != null) {
        _ref.style.width = "" + this.opts.style.crosshairThickness + "px";
      }
      return (_ref1 = this.crosshairs.y) != null ? _ref1.style.height = "" + this.opts.style.crosshairThickness + "px" : void 0;
    };

    MouseTracker.prototype.setup_crosshairs = function() {
      var c, coord, _ref, _results;
      this.crosshairs = {};
      this.crosshairs.x = JRule.Crosshair.create('x', "50%", this.opts.style);
      this.crosshairs.y = JRule.Crosshair.create('y', "50%", this.opts.style);
      _ref = this.crosshairs;
      _results = [];
      for (coord in _ref) {
        c = _ref[coord];
        _results.push(document.body.appendChild(c));
      }
      return _results;
    };

    MouseTracker.prototype.render_crosshairs = function() {
      var offset;
      if (!this.crosshairs) {
        this.setup_crosshairs();
      }
      offset = this.opts.style.crosshairThickness === 1 ? 0 : Math.round(this.opts.style.crosshairThickness / 2);
      this.crosshairs.x.style.left = "" + (this.mousex - offset) + "px";
      return this.crosshairs.y.style.top = "" + (this.mousey - offset) + "px";
    };

    MouseTracker.prototype.toggle_crosshairs = function() {
      this.opts.show_crosshairs = !this.opts.show_crosshairs;
      if (!this.opts.show_crosshairs) {
        return this.remove_crosshairs();
      }
    };

    MouseTracker.prototype.remove_crosshairs = function() {
      var c, coord, _ref;
      _ref = this.crosshairs;
      for (coord in _ref) {
        c = _ref[coord];
        document.body.removeChild(c);
      }
      return this.crosshairs = null;
    };

    return MouseTracker;

  })();

  JRule.BorderRulers = (function() {
    function BorderRulers(opts) {
      this.opts = opts != null ? opts : {};
      this.rulers = {};
      this.mouse_ticks = {};
      this.mouse_tracker = JRule.MouseTracker.get_tracker();
      this.default_opts();
      this.setup_rulers();
      this.setup_events();
    }

    BorderRulers.prototype.default_opts = function() {
      var defaults;
      defaults = {
        style: {
          backgroundColor: "#aaa",
          opacity: .5,
          tickColor: "#ccc",
          mouseTickColor: "#00f"
        },
        top: true,
        left: true,
        right: false,
        bottom: false,
        tick_distance: 100,
        rule_size: 25,
        divisions: 8,
        show_mouse: true,
        show_labels: true,
        start_in_center: true
      };
      return this.opts = defaults;
    };

    BorderRulers.prototype.get_style = function() {
      return {
        backgroundColor: this.opts.style.backgroundColor,
        opacity: this.opts.style.opacity
      };
    };

    BorderRulers.prototype.setup_rulers = function(force) {
      var create_ruler, left_ruler, name, ruler, top_ruler, _ref, _ref1;
      if (force == null) {
        force = false;
      }
      if (this.setup && !force) {
        return;
      }
      if (this.setup && force) {
        this.destroy();
      }
      create_ruler = (function(_this) {
        return function() {
          var key, rule, val, _ref;
          rule = document.createElement("div");
          _ref = _this.get_style();
          for (key in _ref) {
            val = _ref[key];
            rule.style[key] = val;
          }
          rule.className = "ruler";
          rule.style.position = "fixed";
          rule.style.zIndex = 4000;
          return rule;
        };
      })(this);
      if (this.opts.top) {
        top_ruler = create_ruler();
        top_ruler.style.left = 0;
        top_ruler.style.right = 0;
        top_ruler.style.top = 0;
        top_ruler.style.height = "" + this.opts.rule_size + "px";
        this.rulers.top = top_ruler;
      }
      if (this.opts.left) {
        left_ruler = create_ruler();
        left_ruler.style.left = 0;
        left_ruler.style.top = 0;
        left_ruler.style.bottom = 0;
        left_ruler.style.width = "" + this.opts.rule_size + "px";
        this.rulers.left = left_ruler;
      }
      _ref = this.rulers;
      for (name in _ref) {
        ruler = _ref[name];
        if ((_ref1 = document.body) != null) {
          _ref1.appendChild(ruler);
        }
      }
      this.setup_ticks();
      this.shown = true;
      this.setup = true;
      return this;
    };

    BorderRulers.prototype.setup_events = function() {
      if (this.opts.show_mouse) {
        return document.body.addEventListener('jrule:mousemove', (function(_this) {
          return function(e) {
            return _this.render();
          };
        })(this));
      }
    };

    BorderRulers.prototype.tick_style = function(side) {
      var style;
      style = {
        position: "absolute",
        display: "block",
        backgroundColor: this.opts.style.tickColor
      };
      if (side === "top" || side === "bottom") {
        style.width = "1px";
        style.height = "100%";
      } else {
        style.width = "100%";
        style.height = "1px";
      }
      return style;
    };

    BorderRulers.prototype.create_label = function(side, pos) {
      var label;
      label = document.createElement("div");
      label.className = "tick_label";
      set_text(label, "" + pos + "px");
      label.style.position = "absolute";
      label.style.fontSize = "10px";
      label.style.fontFamily = "sans-serif";
      if (side === "top") {
        label.style.left = "" + pos + "px";
        label.style.bottom = "2px";
        label.style.marginLeft = "-14px";
      } else {
        label.style.top = "" + pos + "px";
        label.style.left = "4px";
        label.style["-webkit-transform"] = "rotate(-90deg)";
        label.style["transform"] = "rotate(-90deg)";
        label.style["-moz-transform"] = "rotate(-90deg)";
      }
      return label;
    };

    BorderRulers.prototype.setup_ticks = function() {
      var div_pos, division_distance, doc_rect, i, j, mouse_pos, mouse_x_tick, mouse_y_tick, side, tick_distance, tick_label, tick_pos, ticks, _i, _j, _k, _len, _ref, _ref1;
      doc_rect = document.body.getBoundingClientRect();
      ticks = Math.ceil(doc_rect.width / this.opts.tick_distance);
      tick_distance = Math.round(doc_rect.width / ticks);
      division_distance = Math.round(tick_distance / this.opts.divisions);
      _ref = ['top', 'left'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        side = _ref[_i];
        for (i = _j = 0; 0 <= ticks ? _j < ticks : _j > ticks; i = 0 <= ticks ? ++_j : --_j) {
          tick_pos = i * this.opts.tick_distance;
          this.draw_tick(side, tick_pos, 1, {
            backgroundColor: "#666"
          });
          if (this.opts.show_labels) {
            tick_label = this.create_label(side, tick_pos);
            this.rulers[side].appendChild(tick_label);
          }
          for (j = _k = 1, _ref1 = this.opts.divisions; 1 <= _ref1 ? _k < _ref1 : _k > _ref1; j = 1 <= _ref1 ? ++_k : --_k) {
            div_pos = j * division_distance + tick_pos;
            this.draw_tick(side, div_pos, (j % 2 ? .3 : .5));
          }
        }
      }
      if (this.opts.show_mouse) {
        if (this.rulers.hasOwnProperty('top')) {
          mouse_x_tick = this.create_tick('top', Math.round(doc_rect.width / 2), 1);
          mouse_x_tick.style.backgroundColor = "" + this.opts.style.mouseTickColor;
          this.mouse_ticks.x = mouse_x_tick;
          this.rulers.top.appendChild(this.mouse_ticks.x);
        }
        if (this.rulers.hasOwnProperty('left')) {
          mouse_y_tick = this.create_tick('left', Math.round(doc_rect.width / 2), 1);
          mouse_y_tick.style.backgroundColor = "" + this.opts.style.mouseTickColor;
          this.mouse_ticks.y = mouse_y_tick;
          this.rulers.left.appendChild(this.mouse_ticks.y);
        }
        mouse_pos = document.createElement("div");
        mouse_pos.style.position = "fixed";
        mouse_pos.style.zIndex = 5000;
        mouse_pos.style.left = 0;
        mouse_pos.style.top = 0;
        mouse_pos.style.padding = "6px";
        mouse_pos.style.backgroundColor = "#888";
        mouse_pos.style.color = "#fafafa";
        mouse_pos.style.fontSize = "12px";
        mouse_pos.style.fontFamily = "sans-serif";
        mouse_pos.style.fontWeight = 100;
        this.mouse_pos = mouse_pos;
        return document.body.appendChild(this.mouse_pos);
      }
    };

    BorderRulers.prototype.create_tick = function(side, pos, height, style_overrides) {
      var key, new_tick, val, _ref;
      if (height == null) {
        height = 1;
      }
      if (style_overrides == null) {
        style_overrides = {};
      }
      new_tick = document.createElement("div");
      _ref = this.tick_style(side);
      for (key in _ref) {
        val = _ref[key];
        if (style_overrides.hasOwnProperty(key)) {
          new_tick.style[key] = style_overrides[key];
        } else {
          new_tick.style[key] = val;
        }
      }
      new_tick.className = "tick";
      if (side === "top" || side === "bottom") {
        new_tick.style.left = "" + pos + "px";
        new_tick.style.height = "" + (100 * height) + "%";
      } else {
        new_tick.style.top = "" + pos + "px";
        new_tick.style.width = "" + (100 * height) + "%";
      }
      return new_tick;
    };

    BorderRulers.prototype.draw_tick = function(side, pos, height, style_overrides) {
      var new_tick;
      if (height == null) {
        height = 1;
      }
      if (style_overrides == null) {
        style_overrides = {};
      }
      if (this.rulers.hasOwnProperty(side)) {
        new_tick = this.create_tick(side, pos, height, style_overrides);
        return this.rulers[side].appendChild(new_tick);
      } else {
        return false;
      }
    };

    BorderRulers.prototype.destroy = function() {};

    BorderRulers.prototype.render = function() {
      if (this.opts.show_mouse) {
        if (this.mouse_ticks.x) {
          this.mouse_ticks.x.style.left = "" + this.mouse_tracker.mousex + "px";
        }
        if (this.mouse_ticks.y) {
          this.mouse_ticks.y.style.top = "" + this.mouse_tracker.mousey + "px";
        }
        return set_text(this.mouse_pos, "" + this.mouse_tracker.mousex + ", " + this.mouse_tracker.mousey);
      }
    };

    BorderRulers.prototype.toggle_visibility = function() {
      var ruler, side, _ref, _results;
      this.shown = !this.shown;
      _ref = this.rulers;
      _results = [];
      for (side in _ref) {
        ruler = _ref[side];
        _results.push(ruler.style.display = this.shown ? "block" : "none");
      }
      return _results;
    };

    return BorderRulers;

  })();

  JRule.Caliper = (function() {
    function Caliper(opts) {
      this.opts = opts != null ? opts : {};
      this.mouse_tracker = JRule.MouseTracker.get_tracker();
      this.crosshairs = [];
      this.setup_events();
    }

    Caliper.prototype.setup_events = function() {
      document.addEventListener('keydown', (function(_this) {
        return function(e) {
          var keyup_fn;
          if (e.keyCode === 16) {
            _this.measuring = true;
            _this.start_pos = [_this.mouse_tracker.mousex, _this.mouse_tracker.mousey];
            _this.mark_spot_with_crosshair(_this.start_pos);
            document.body.style.cursor = "none";
            _this.setup_indicators();
            keyup_fn = function() {
              _this.measuring = false;
              _this.end_pos = [_this.mouse_tracker.mousex, _this.mouse_tracker.mousey];
              document.removeEventListener('keyup', keyup_fn);
              return _this.cleanup();
            };
            return document.addEventListener('keyup', keyup_fn);
          }
        };
      })(this));
      return document.body.addEventListener('jrule:mousemove', (function(_this) {
        return function() {
          return _this.render();
        };
      })(this));
    };

    Caliper.prototype.render = function() {
      var h_dir, height, v_dir, width, x, y;
      if (this.measuring) {
        x = Math.min(this.mouse_tracker.mousex, this.start_pos[0]);
        y = Math.min(this.mouse_tracker.mousey, this.start_pos[1]);
        width = Math.max(this.mouse_tracker.mousex, this.start_pos[0]) - Math.min(this.mouse_tracker.mousex, this.start_pos[0]);
        height = Math.max(this.mouse_tracker.mousey, this.start_pos[1]) - Math.min(this.mouse_tracker.mousey, this.start_pos[1]);
        this.indicator.style.width = "" + width + "px";
        this.indicator.style.height = "" + height + "px";
        this.indicator.style.left = "" + x + "px";
        this.indicator.style.top = "" + y + "px";
        this.indicator.style.zIndex = 5000;
        this.indicator_size.style.display = 'block';
        h_dir = this.start_pos[0] > this.mouse_tracker.mousex ? "left" : "right";
        v_dir = this.start_pos[1] > this.mouse_tracker.mousey ? "up" : "down";
        this.drag_direction = [h_dir, v_dir];
        if (h_dir === "left") {
          this.indicator_size.style.left = 0;
          this.indicator_size.style.right = "auto";
        } else {
          this.indicator_size.style.right = 0;
          this.indicator_size.style.left = "auto";
        }
        if (v_dir === "up") {
          this.indicator_size.style.top = 0;
          this.indicator_size.style.bottom = "auto";
        } else {
          this.indicator_size.style.bottom = 0;
          this.indicator_size.style.top = "auto";
        }
        return set_text(this.indicator_size, "" + width + ", " + height);
      }
    };

    Caliper.prototype.setup_indicators = function() {
      var indicator, indicator_size;
      indicator = document.createElement("div");
      indicator.style.position = "fixed";
      indicator.style.left = "" + this.start_pos[0] + "px";
      indicator.style.top = "" + this.start_pos[1] + "px";
      indicator.style.backgroundColor = "rgba(100, 100, 100, .4)";
      indicator.style.zIndex = 3999;
      this.indicator = indicator;
      document.body.appendChild(this.indicator);
      indicator_size = document.createElement("div");
      indicator_size.style.position = "absolute";
      indicator_size.style.right = 0;
      indicator_size.style.bottom = 0;
      indicator_size.style.fontFamily = "sans-serif";
      indicator_size.style.fontSize = "12px";
      indicator_size.style.backgroundColor = "#000";
      indicator_size.style.color = "#fff";
      indicator_size.style.padding = "3px";
      indicator_size.style.zIndex = 1;
      this.indicator_size = indicator_size;
      return this.indicator.appendChild(this.indicator_size);
    };

    Caliper.prototype.mark_spot_with_crosshair = function(pos) {
      var c, _i, _len, _ref, _results;
      this.crosshairs.push(JRule.Crosshair.create('x', "" + pos[0] + "px"));
      this.crosshairs.push(JRule.Crosshair.create('y', "" + pos[1] + "px"));
      _ref = this.crosshairs;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(document.body.appendChild(c));
      }
      return _results;
    };

    Caliper.prototype.cleanup = function() {
      var c, _i, _len, _ref;
      this.indicator.removeChild(this.indicator_size);
      document.body.removeChild(this.indicator);
      _ref = this.crosshairs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        document.body.removeChild(c);
      }
      this.crosshairs = [];
      return document.body.style.cursor = "default";
    };

    return Caliper;

  })();

  JRule.Grid = (function() {
    function Grid(opts) {
      this.opts = opts != null ? opts : {};
      this.default_opts();
      this.setup_grid();
      this.setup_events();
    }

    Grid.prototype.default_opts = function() {
      var defaults, key, key2, val, val2, _ref;
      defaults = {
        tick_distance: 100,
        divisions: 3,
        show: false,
        start_in_center: true,
        style: {
          tickLineColor: "rgba(191, 231, 243, .6)",
          divisionLineColor: "rgba(220, 220, 220, .3)",
          centerLineColor: "rgba(255, 0, 0, .3)"
        }
      };
      for (key in defaults) {
        val = defaults[key];
        if (!this.opts.hasOwnProperty(key)) {
          this.opts[key] = val;
        } else if (typeof this.opts[key] === "object") {
          _ref = this.opts[key];
          for (key2 in _ref) {
            val2 = _ref[key2];
            if (!this.opts[key].hasOwnProperty(key2)) {
              this.opts[key][key] = val2;
            }
          }
        }
      }
      return this.opts;
    };

    Grid.prototype.setup_events = function() {
      this.window_resizing = false;
      this.resize_to = null;
      return window.addEventListener('resize', (function(_this) {
        return function(e) {
          if (_this.window_resizing) {
            if (_this.resize_to) {
              clearTimeout(_this.resize_to);
            }
            return _this.resize_to = setTimeout(function() {
              _this.window_resizing = false;
              _this.setup_grid();
              return _this.show_ticks();
            }, 400);
          } else {
            _this.window_resizing = true;
            return _this.cleanup();
          }
        };
      })(this));
    };

    Grid.prototype.setup_grid = function() {
      var center_x, center_y, division_distance, i, n, num_ticks, offset, t, x_offset, y_offset, _i, _j, _k, _l, _len, _m, _ref, _ref1, _ref2, _ref3;
      center_x = Math.round(document.documentElement.clientWidth / 2);
      center_y = Math.round(document.documentElement.clientHeight / 2);
      num_ticks = Math.ceil(document.documentElement.clientWidth / this.opts.tick_distance);
      division_distance = this.opts.divisions > 0 ? Math.round(this.opts.tick_distance / this.opts.divisions) : 0;
      this.ticks = [];
      if (this.opts.start_in_center) {
        num_ticks = num_ticks / 2;
        this.ticks.push(JRule.Crosshair.create('x', "" + center_x + "px", {
          crosshairColor: this.opts.style.centerLineColor
        }));
        this.ticks.push(JRule.Crosshair.create('y', "" + center_y + "px", {
          crosshairColor: this.opts.style.centerLineColor
        }));
        if (this.opts.divisions > 0) {
          for (n = _i = 1, _ref = this.opts.divisions; 1 <= _ref ? _i < _ref : _i > _ref; n = 1 <= _ref ? ++_i : --_i) {
            this.ticks.push(JRule.Crosshair.create('x', "" + (center_x + n * division_distance) + "px", {
              crosshairColor: this.opts.style.divisionLineColor
            }));
            this.ticks.push(JRule.Crosshair.create('y', "" + (center_y + n * division_distance) + "px", {
              crosshairColor: this.opts.style.divisionLineColor
            }));
            this.ticks.push(JRule.Crosshair.create('x', "" + (center_x - n * division_distance) + "px", {
              crosshairColor: this.opts.style.divisionLineColor
            }));
            this.ticks.push(JRule.Crosshair.create('y', "" + (center_y - n * division_distance) + "px", {
              crosshairColor: this.opts.style.divisionLineColor
            }));
          }
        }
      }
      for (i = _j = 1; 1 <= num_ticks ? _j < num_ticks : _j > num_ticks; i = 1 <= num_ticks ? ++_j : --_j) {
        offset = i * this.opts.tick_distance;
        x_offset = this.opts.start_in_center ? center_x + offset : offset;
        y_offset = this.opts.start_in_center ? center_y + offset : offset;
        this.ticks.push(JRule.Crosshair.create('x', "" + x_offset + "px", {
          crosshairColor: this.opts.style.tickLineColor
        }));
        this.ticks.push(JRule.Crosshair.create('y', "" + y_offset + "px", {
          crosshairColor: this.opts.style.tickLineColor
        }));
        if (this.opts.divisions > 0) {
          for (n = _k = 1, _ref1 = this.opts.divisions; 1 <= _ref1 ? _k < _ref1 : _k > _ref1; n = 1 <= _ref1 ? ++_k : --_k) {
            this.ticks.push(JRule.Crosshair.create('x', "" + (x_offset + n * division_distance) + "px", {
              crosshairColor: this.opts.style.divisionLineColor
            }));
            this.ticks.push(JRule.Crosshair.create('y', "" + (y_offset + n * division_distance) + "px", {
              crosshairColor: this.opts.style.divisionLineColor
            }));
          }
        }
        if (this.opts.start_in_center) {
          this.ticks.push(JRule.Crosshair.create('x', "" + (center_x - offset) + "px", {
            crosshairColor: this.opts.style.tickLineColor
          }));
          this.ticks.push(JRule.Crosshair.create('y', "" + (center_y - offset) + "px", {
            crosshairColor: this.opts.style.tickLineColor
          }));
          if (this.opts.divisions > 0) {
            for (n = _l = 1, _ref2 = this.opts.divisions; 1 <= _ref2 ? _l < _ref2 : _l > _ref2; n = 1 <= _ref2 ? ++_l : --_l) {
              this.ticks.push(JRule.Crosshair.create('x', "" + (center_x - offset - n * division_distance) + "px", {
                crosshairColor: this.opts.style.divisionLineColor
              }));
              this.ticks.push(JRule.Crosshair.create('y', "" + (center_y - offset - n * division_distance) + "px", {
                crosshairColor: this.opts.style.divisionLineColor
              }));
            }
          }
        }
      }
      _ref3 = this.ticks;
      for (_m = 0, _len = _ref3.length; _m < _len; _m++) {
        t = _ref3[_m];
        document.body.appendChild(t);
      }
      if (this.opts.show) {
        return this.show_ticks();
      } else {
        return this.hide_ticks();
      }
    };

    Grid.prototype.cleanup = function() {
      var t, _i, _len, _ref, _results;
      _ref = this.ticks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        _results.push(document.body.removeChild(t));
      }
      return _results;
    };

    Grid.prototype.hide_ticks = function() {
      var t, _i, _len, _ref, _results;
      this.shown = false;
      _ref = this.ticks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        _results.push(t.style.display = "none");
      }
      return _results;
    };

    Grid.prototype.show_ticks = function() {
      var t, _i, _len, _ref, _results;
      this.shown = true;
      _ref = this.ticks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        _results.push(t.style.display = "block");
      }
      return _results;
    };

    Grid.prototype.toggle_grid = function() {
      this.shown = !this.shown;
      if (this.shown) {
        return this.show_ticks();
      } else {
        return this.hide_ticks();
      }
    };

    return Grid;

  })();

  document.JRule = JRule;

  ready = function() {
    return document.jruler = new document.JRule();
  };

  if (document.readyState !== "complete") {
    document.addEventListener('DOMContentLoaded', function() {
      return ready();
    });
  } else {
    ready();
  }

}).call(this);
